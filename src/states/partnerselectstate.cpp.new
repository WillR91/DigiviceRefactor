// File: src/states/PartnerSelectState.cpp

#include "states/PartnerSelectState.h" // Include own header
#include "core/Game.h"                 // For game_ptr, state changes, managers
#include "ui/TextRenderer.h"           // For TextRenderer class
#include "core/AssetManager.h"         // For assets
#include "core/InputManager.h"         // For InputManager&
#include "core/GameAction.h"           // For GameAction enum
#include "core/PlayerData.h"           // For PlayerData*
#include "platform/pc/pc_display.h"    // For PCDisplay& and rendering
#include "graphics/Animator.h"         // For digimonAnimator_
#include "graphics/AnimationData.h"    // For AnimationData struct
#include "core/AnimationManager.h"     // To get AnimationData
#include "utils/AnimationUtils.h"      // For animation utilities
#include "entities/DigimonRegistry.h"  // For DigimonRegistry
#include <SDL_log.h>
#include <stdexcept>                   // For runtime_error

PartnerSelectState::PartnerSelectState(Game* game) :
    GameState(game),
    currentSelectionIndex_(0),
    backgroundTexture_(nullptr),
    digimonAnimator_() // Default construct the animator
{
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState Constructor Called.");
    if (!game_ptr) { throw std::runtime_error("PartnerSelectState requires a valid Game pointer!"); }
    if (!game_ptr->getAnimationManager()) { throw std::runtime_error("PartnerSelectState requires AnimationManager!");}
    if (!game_ptr->getTextRenderer()) { throw std::runtime_error("PartnerSelectState requires TextRenderer!");}
    if (!game_ptr->getDigimonRegistry()) { throw std::runtime_error("PartnerSelectState requires DigimonRegistry!");}

    // Store IDs instead of enum values
    availablePartnerIds_ = {
        "agumon", "gabumon", "biyomon", "gatomon",
        "gomamon", "palmon", "tentomon", "patamon"
    };
    
    if (availablePartnerIds_.empty()) {
        throw std::runtime_error("PartnerSelectState: No available partners defined!");
    }

    AssetManager* assets = game_ptr->getAssetManager();
    if (!assets) { throw std::runtime_error("PartnerSelectState requires a valid AssetManager!"); }

    backgroundTexture_ = assets->getTexture("menu_bg_blue");
    if (!backgroundTexture_) { SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,"PartnerSelectState: Background texture not found!"); }

    PlayerData* pd = game_ptr->getPlayerData();
    if (pd) {
        std::string currentPartnerId = pd->getCurrentPartnerId();
        for (size_t i = 0; i < availablePartnerIds_.size(); ++i) {
            if (availablePartnerIds_[i] == currentPartnerId) {
                currentSelectionIndex_ = i;
                break;
            }
        }
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState: Initial selection set to index %zu based on PlayerData.", currentSelectionIndex_);
    } else {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,"PartnerSelectState: Could not get PlayerData! Defaulting selection to index 0.");
        currentSelectionIndex_ = 0;
    }

    // Set the initially displayed Digimon animation
    updateDisplayedDigimon();

    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState Initialized.");
}

PartnerSelectState::~PartnerSelectState() {
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState Destructor Called.");
}

void PartnerSelectState::enter() {
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "--- PartnerSelectState enter() CALLED ---");
    updateDisplayedDigimon(); // Refresh animation when entering
}

void PartnerSelectState::handle_input(InputManager& inputManager, PlayerData* playerData) {
    if (!game_ptr) return;

    if (inputManager.isActionJustPressed(GameAction::NAV_UP)) {
        currentSelectionIndex_ = (currentSelectionIndex_ == 0) ? 
            availablePartnerIds_.size() - 1 : currentSelectionIndex_ - 1;
        updateDisplayedDigimon();
    } else if (inputManager.isActionJustPressed(GameAction::NAV_DOWN)) {
        currentSelectionIndex_ = (currentSelectionIndex_ + 1) % availablePartnerIds_.size();
        updateDisplayedDigimon();
    }
    
    if (inputManager.isActionJustPressed(GameAction::CONFIRM)) {
        if (!availablePartnerIds_.empty() && playerData && game_ptr) { // Added game_ptr check for safety
            std::string selectedPartnerId = availablePartnerIds_[currentSelectionIndex_];
            playerData->setCurrentPartnerId(selectedPartnerId);
            
            Digimon::DigimonRegistry* registry = game_ptr->getDigimonRegistry();
            const Digimon::DigimonDefinition* partnerDef = registry->getDefinitionById(selectedPartnerId);
            
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                        "PartnerSelectState: CONFIRM selected %s. Game ptr: %p",
                        (partnerDef ? partnerDef->displayName.c_str() : selectedPartnerId.c_str()),
                        (void*)game_ptr);
            
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState: Calling requestFadeToState(nullptr, 0.5f, true)");
            game_ptr->requestFadeToState(nullptr, 0.5f, true); // Pop PartnerSelectState

            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState: Calling setTargetStateAfterFade(StateType::Adventure)");
            game_ptr->setTargetStateAfterFade(StateType::Adventure); // Target AdventureState after fade & pop
            
            // Set our internal state to indicate we're returning to adventure
            returnToAdventure_ = true;
        }
    } else if (inputManager.isActionJustPressed(GameAction::CANCEL)) {
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState: CANCEL pressed. Requesting pop via fade.");
        if (game_ptr) {
            // Just pop without setting partner
            game_ptr->requestFadeToState(nullptr, 0.5f, true);
        }
    }
}

void PartnerSelectState::update(float delta_time, PlayerData* playerData) {
    // Just update the animator without checking (it should handle null animations internally)
    digimonAnimator_.update(delta_time);
    
    // We've simplified the code by removing the fade transition logic
    // and directly popping to the adventure state from handle_input
}

void PartnerSelectState::render(PCDisplay& display) {
    SDL_Renderer* renderer = display.getRenderer();
    if (!renderer) return;

    int windowW = 0; int windowH = 0;
    display.getWindowSize(windowW, windowH);
    if (windowW <= 0 || windowH <= 0) { windowW = 466; windowH = 466; }

    if (backgroundTexture_) {
        SDL_RenderCopy(renderer, backgroundTexture_, NULL, NULL);
    } else {
        SDL_SetRenderDrawColor(renderer, 0, 50, 0, 255);
        SDL_RenderClear(renderer);
    }

    drawDigimon(display);
    
    TextRenderer* textRenderer = game_ptr ? game_ptr->getTextRenderer() : nullptr;
    if (textRenderer && !availablePartnerIds_.empty()) {
        std::string partnerId = availablePartnerIds_[currentSelectionIndex_];
        std::string name = getDigimonName(partnerId);

        if (!name.empty()) {
            const float nameScale = 0.9f;
            const int nameKerning = -15;
            SDL_Point baseDimensions = textRenderer->getTextDimensions(name, nameKerning);
            if (baseDimensions.x > 0 && baseDimensions.y > 0) {
                int scaledW = static_cast<int>(static_cast<float>(baseDimensions.x) * nameScale);
                int scaledH = static_cast<int>(static_cast<float>(baseDimensions.y) * nameScale);
                int nameX = (windowW / 2) - (scaledW / 2);
                int nameY = (windowH * 2 / 3) - (scaledH / 2);
                textRenderer->drawText(renderer, name, nameX, nameY, nameScale, nameKerning);
            } else { /* Warn */ }
        }
    } else { /* Warn */ }
}

void PartnerSelectState::drawDigimon(PCDisplay& display) {
    SDL_Renderer* renderer = display.getRenderer();
    if (!renderer) return;

    int windowW = 0; int windowH = 0;
    display.getWindowSize(windowW, windowH);
    if (windowW <= 0 || windowH <= 0) { windowW = 466; windowH = 466; }

    SDL_Texture* currentTexture = digimonAnimator_.getCurrentTexture();
    SDL_Rect currentSourceRect = digimonAnimator_.getCurrentFrameRect();

    if (currentTexture && currentSourceRect.w > 0 && currentSourceRect.h > 0) {
        int drawX = (windowW / 2) - (currentSourceRect.w / 2);
        int drawY = (windowH / 2) - (currentSourceRect.h / 2) - 65;
        SDL_Rect dstRect = { drawX, drawY, currentSourceRect.w, currentSourceRect.h };
        display.drawTexture(currentTexture, &currentSourceRect, &dstRect);
    } else {
        SDL_SetRenderDrawColor(renderer, 255, 0, 255, 255);
        int w = 50, h = 50;
        int x = (windowW / 2) - (w / 2);
        int y = (windowH / 2) - (h / 2) - 30;
        SDL_Rect placeholder = {x, y, w, h};
        SDL_RenderFillRect(renderer, &placeholder);
    }
}

void PartnerSelectState::updateDisplayedDigimon() {
    if (availablePartnerIds_.empty() || !game_ptr || !game_ptr->getAnimationManager() || !game_ptr->getDigimonRegistry()) {
        digimonAnimator_.stop();
        return;
    }

    std::string partnerId = availablePartnerIds_[currentSelectionIndex_];
    Digimon::DigimonRegistry* registry = game_ptr->getDigimonRegistry();
    const Digimon::DigimonDefinition* partnerDef = registry->getDefinitionById(partnerId);
    
    if (!partnerDef) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "PartnerSelectState: No definition found for partner ID: %s", partnerId.c_str());
        digimonAnimator_.stop();
        return;
    }
    
    std::string animId = AnimationUtils::GetAnimationId(partnerDef->spriteBaseId, "Idle");
    AnimationManager* animManager = game_ptr->getAnimationManager();
    const AnimationData* animData = animManager->getAnimationData(animId);
    digimonAnimator_.setAnimation(animData);
}

std::string PartnerSelectState::getPartnerIdFromIndex(size_t index) const {
    if (index < availablePartnerIds_.size()) { return availablePartnerIds_[index]; }
    return "agumon"; // Fallback
}

std::string PartnerSelectState::getDigimonName(const std::string& partnerId) const {
    if (!game_ptr || !game_ptr->getDigimonRegistry()) {
        return partnerId; // Fallback to ID if registry not available
    }
    
    Digimon::DigimonRegistry* registry = game_ptr->getDigimonRegistry();
    const Digimon::DigimonDefinition* partnerDef = registry->getDefinitionById(partnerId);
    
    if (partnerDef) {
        return partnerDef->displayName;
    } else {
        return partnerId; // Fallback
    }
}

std::string PartnerSelectState::getAnimationId(const std::string& partnerId, const std::string& animName) const {
    if (!game_ptr || !game_ptr->getDigimonRegistry()) {
        return ""; // Can't resolve without registry
    }
    
    Digimon::DigimonRegistry* registry = game_ptr->getDigimonRegistry();
    const Digimon::DigimonDefinition* partnerDef = registry->getDefinitionById(partnerId);
    
    if (partnerDef) {
        return AnimationUtils::GetAnimationId(partnerDef->spriteBaseId, animName);
    } else {
        return ""; // Fallback
    }
}

StateType PartnerSelectState::getType() const {
    return StateType::PartnerSelect;
}
